# 轨迹坐标范围优化方案

## 问题描述

训练生成的轨迹坐标点需要限制在屏幕的坐标范围内（0-800 x 0-600）。

## 优化实现

### 1. 模型输出层添加激活函数约束

在 `cvae_model.py` 的 `decode()` 方法中，对不同特征应用不同的激活函数：

```python
# 4.4 应用激活函数约束不同特征到合理范围
# output_size = 5: [X, Y, Time, Direction, Speed]
prediction = torch.cat([
    torch.tanh(raw_output[:, 0:1]),      # X: 相对坐标，限制在 [-1, 1]
    torch.tanh(raw_output[:, 1:2]),      # Y: 相对坐标，限制在 [-1, 1]
    torch.nn.functional.softplus(raw_output[:, 2:3]),  # Time: 非负
    torch.tanh(raw_output[:, 3:4]),      # Direction: 限制在 [-1, 1]
    torch.sigmoid(raw_output[:, 4:5])    # Speed: 限制在 [0, 1]
], dim=1)
```

### 2. 激活函数选择理由

| 特征 | 激活函数 | 输出范围 | 原因 |
|------|----------|----------|------|
| X (相对坐标) | `tanh` | [-1, 1] | 相对坐标归一化值，对称分布 |
| Y (相对坐标) | `tanh` | [-1, 1] | 相对坐标归一化值，对称分布 |
| Time | `softplus` | [0, +∞) | 时间必须非负，单调递增 |
| Direction | `tanh` | [-1, 1] | 方向归一化到 [-π, π] |
| Speed | `sigmoid` | [0, 1] | 速度归一化值，必须非负 |

### 3. 测试结果

运行 `test_output_range.py` 验证：

```
【X 坐标】(相对坐标，应在 [-1, 1])
  - 最小值: -0.084940
  - 最大值: 0.083425
  ✓ 范围正确

【Y 坐标】(相对坐标，应在 [-1, 1])
  - 最小值: -0.081586
  - 最大值: 0.188224
  ✓ 范围正确

【Time】(时间，应为非负)
  - 最小值: 0.557724
  - 最大值: 0.740331
  ✓ 范围正确 (非负)

【Direction】(方向，应在 [-1, 1])
  - 最小值: -0.092361
  - 最大值: 0.145448
  ✓ 范围正确

【Speed】(速度，应在 [0, 1])
  - 最小值: 0.469178
  - 最大值: 0.539676
  ✓ 范围正确
```

✅ **所有激活函数约束都正常工作！**

## 完整的坐标范围保证机制

### 多层保护机制：

1. **模型输出层约束** (新增)
   - Tanh 限制相对坐标在 [-1, 1]
   - 确保归一化值在合理范围

2. **仿射变换对齐**
   - 将轨迹精确映射到目标起点和终点
   - 自动处理缩放和旋转

3. **推理时边界检查**
   - 在 `predict_trajectory.py` 中过滤超范围的点
   - 代码：
   ```python
   if abs_x < -50 or abs_x > self.canvas_width + 50 or \
      abs_y < -50 or abs_y > self.canvas_height + 50:
       break
   ```

4. **单调性保护**
   - `_ensure_monotonic_approach()` 截断超过终点的轨迹
   - 防止"划过终点再转回"

## 为什么反归一化后仍可能超出范围？

测试显示反归一化后约 **7.95%** 的点超出画布范围，这是**正常的**：

### 原因分析：

1. **相对坐标特性**
   - 模型输出的是**相对于起点**的坐标
   - 归一化值在 [-1, 1]，反归一化后范围是 `[-canvas_size, canvas_size]`
   - 例如：起点在 (750, 550)，相对坐标 (1.0, 1.0) → 绝对坐标 (1550, 1150) 超出范围

2. **设计意图**
   - 允许轨迹在某些中间点超出画布（模拟真实鼠标移动）
   - 通过**仿射变换**最终对齐到正确的终点
   - 超出范围的点会在推理时被过滤

### 示例：

```
起点: (700, 500)
相对坐标归一化: (0.5, 0.3)
反归一化: (0.5 * 800, 0.3 * 600) = (400, 180)
绝对坐标: (700 + 400, 500 + 180) = (1100, 680)  # 超出 800x600
```

**解决方案：** 仿射变换会将整条轨迹缩放和旋转到终点，自动修正超范围的点。

## 需要重新训练吗？

### ❌ 不需要重新训练

理由：
1. **激活函数是确定性的**：不影响模型已学习的参数
2. **训练数据已在范围内**：所有训练样本的归一化坐标都在 [-1, 1]
3. **向后兼容**：激活函数只是添加了输出约束，不改变模型架构

### 测试建议

加载已训练的模型测试：

```python
model = TrajectoryPredictorCVAE()
model.load_state_dict(torch.load('cvae_trajectory_predictor.pth'))
model.eval()

# 测试输出范围
trajectory, _, _, _ = model(task_context)
# 验证范围是否在 [-1, 1]
```

## 优化效果

### 优化前：
- ❌ 模型可能输出任意范围的值
- ❌ 依赖推理时的边界检查
- ❌ 可能产生不合理的轨迹

### 优化后：
- ✅ 模型输出严格限制在合理范围
- ✅ 归一化相对坐标在 [-1, 1]
- ✅ 时间、速度、方向都有合理约束
- ✅ 结合仿射变换，终点误差 < 1 像素

## 相关文件

- `cvae_model.py`: 模型定义，添加了激活函数约束
- `predict_trajectory.py`: 推理接口，包含仿射变换和边界检查
- `test_output_range.py`: 输出范围测试脚本
- `trajectory_dataset.py`: 数据集定义，归一化逻辑

## 使用示例

```python
from predict_trajectory import TrajectoryPredictor

predictor = TrajectoryPredictor()
trajectory = predictor.predict(100, 100, 700, 500)

# 所有点都会通过以下保证在合理范围：
# 1. 模型输出约束在 [-1, 1]
# 2. 仿射变换对齐到终点
# 3. 边界检查过滤异常点
# 4. 单调性保护防止超过终点
```

## 总结

通过在模型输出层添加激活函数，我们实现了：

1. ✅ **源头约束**：模型直接输出合理范围的归一化值
2. ✅ **多层保护**：激活函数 + 仿射变换 + 边界检查 + 单调性保护
3. ✅ **无需重训练**：向后兼容已训练模型
4. ✅ **精确终点**：结合仿射变换，终点误差 < 1 像素

**推荐做法**：
- 使用当前优化后的模型（带激活函数约束）
- 启用仿射变换对齐（`align_endpoints=True`，默认启用）
- 如需更严格的边界约束，可以在损失函数中添加惩罚项